---
title: Late-Night Gaming, Sleep and Wellbeing
subtitle: Optional Subtitle
running-head: Short Title
author:
  - name: First Author
    email: author1@example.com
    orcid: 0000-0000-0000-0000
    url: https://example.com
    corresponding: true
    affiliation:
      - ref: 1
  - name: Second Author
    affiliation:
      - ref: 2
affiliations:
  - id: 1
    name: First University
    department: Department Name
  - id: 2
    name: Second University
abstract: |
  Your abstract goes here. This will appear prominently at the top of your document.
categories: [keyword1, keyword2, keyword3]
authornote: |
  Author notes go here.
date: last-modified
bibliography: bibliography.bib
prefer-html: true
format:
  html:
    toc: true
    toc-location: left
    theme: cosmo
    code-fold: true
    html-math-method: katex
    embed-resources: true
  preprint-typst:
    wordcount: true
    citeproc: true
    # Common options - uncomment to use
    # theme: jou                   # Journal theme (2-column)
    # line-number: true            # Line numbering
    # fontsize: 11pt               # Font size
    # leading: 0.6em               # Line spacing
    # first-line-indent: 1.8em     # Paragraph indent
  docx:
    toc: true
    number-sections: true
    highlight-style: github
---

# Introduction

Concerns have been raised about the potential negative impacts of video gaming on sleep and overall wellbeing, particularly for adolescents and young adults and especially when gaming occurs late at night (Altintas et al., 2019; Exelmans & Van Den Bulck, 2015; Higuchi et al., 2005; King et al., 2013; Peracchia & Curcio, 2018). Late-night gaming has been shown to disrupt sleep patterns, reduce sleep duration, lower sleep quality, and increase daytime sleepiness (Exelmans & Van Den Bulck, 2015; Han et al., 2024; Kim, 2024; Kristensen et al., 2021).This is especially concerning given the far-reaching effects of sleep disturbances on cognitive and emotional functioning (Cain & Gradisar, 2010; LeBourgeois et al., 2017; McCoy & Strecker, 2011; Simon et al., 2020; Vriend et al., 2013). For instance, habitual gaming between 10 p.m. and 6 a.m. has been associated with an increased risk of depressive symptoms, partially mediated by daytime sleepiness (Lemola et al., 2011). Understanding the consequences of late-night gaming is thus vital for both gamers and health professionals.
Two key mechanisms have been proposed to explain the impact of late-night digital engagement—including gaming—on sleep. The first is the displacement hypothesis, which argues that late-night gaming is more harmful than daytime gaming because it cuts into sleep time (Twenge, 2019; Williams et al., 2008). Gamers often feel compelled to continue playing and struggle with self-regulation, which can lead to insufficient sleep (King & Delfabbro, 2009; Pirrone et al., 2024; Spada & Caselli, 2017). For example, adolescents experiencing a heightened sense of "flow" during challenging games delayed bedtime by up to 90 minutes  (Smith et al., 2017). 
The second mechanism involves arousal-related disturbances in sleep architecture caused by late-night gaming. Empirical studies have shown that extended gaming, especially when involving violent content, significantly decreases REM sleep and total sleep time (King et al., 2013). Weaver et al. (2010) highlighted that increased arousal levels due to pre-sleep gaming extend sleep latency and alter the natural progression into sleep stages. This delay in sleep onset could be exacerbated by lower melatonin levels following an evening of gaming, compared to neutral activities like board games, which are crucial for regulating the sleep-wake cycle (Hartmann et al., 2019).  
Negative effects of late-night gaming are often compounded among individuals with an eveningness chronotype—a group naturally predisposed to staying up late. Problematic gamers, who frequently possess this chronotype, are especially vulnerable to the detrimental effects of late-night gaming on sleep (Kristensen et al., 2021). Pre-sleep technology use may exacerbate the misalignment between their biological clock and societal demands by delaying sleep onset and reducing sleep duration, leading to poorer sleep quality and increased daytime sleepiness. Research has linked evening chronotype in adolescents to greater technology use at bedtime, in turn associated with delayed sleep onset, shorter sleep duration, and poorer sleep quality (Bruni et al., 2015; Gumport et al., 2021; Kortesoja et al., 2023; Reardon et al., 2023). Additionally, while Reardon et al. (2023) found that shorter sleep on weekdays was associated with greater psychological distress, technology medium and chronotype were not direct predictors of distress. Gumport et al. (2021) found that technology use improved emotional, social, cognitive, and physical health but worsened behavioral health, measured by the consumption of junk food, caffeine, alcohol, tobacco, and other substances, in evening-type adolescents. It remains unclear how strongly these findings apply to young adults and adults, as most research has focused on adolescent populations. This leaves an open question about the extent to which evening chronotypes in older age groups are similarly affected by pre-sleep technology use.
In sum, the literature indicates that video gaming, particularly when it occurs late at night, has significant implications for sleep quality, sleep duration, and overall wellbeing. This disruption can be attributed to both the displacement hypothesis (Twenge, 2019; Williams et al., 2008) and arousal-related disturbances in sleep architecture (King et al., 2013). Individual differences, such as chronotype, may moderate these effects, with eveningness chronotypes particularly vulnerable to the negative consequences of late-night gaming (Kristensen et al., 2021). The present study aims to empirically test the following hypotheses regarding the relationship between late-night gaming and sleep outcomes:

**H1**: Late-night gaming is associated with:

- **H1a**: Poorer sleep quality
- **H1b**: Shorter sleep duration
- **H1c**: Higher daytime sleepiness
- **H1d**: Lower wellbeing

In addition to testing direct relationships between late-night gaming and various sleep-related outcomes are critical to understand, we further assess the potential moderating role of chronotype, which refers to a person's natural preference for activities during certain times of the day—morningness or eveningness. Individuals with an evening chronotype tend to stay up later and may be more inclined to engage in late-night gaming, potentially exacerbating the negative impacts on sleep and wellbeing. The combination of an evening chronotype and late-night gaming may even have a compounded effect on overall wellbeing, as both factors are independently associated with poorer mental health outcomes. Given this, we propose the following:

**H2**: Chronotype moderates the relationships between late-night gaming and all outcomes in H1 (sleep quality, sleep duration, daytime sleepiness, and wellbeing), such that these negative associations are stronger for individuals with more of an eveningness chronotype.

By examining chronotype on a continuous scale as a moderating factor, this study seeks to provide a more nuanced understanding of the potential risks associated with late-night gaming and to identify individuals who may be most vulnerable to its negative effects.

# Methods

# Results

:::: {.place arguments='top, scope: "parent", float: true'}

```{r}
#| label: load-libraries
#| echo: false
#| message: false
#| warning: false

if (!require("pacman")) install.packages("pacman")
library(pacman)

p_load(tidyverse, lme4, marginaleffects, glmmTMB, mice, ordinal, modelsummary, lubridate, data.table, mctq)

# Source preprocessing functions
source("preprocess_data.R")

# TOGGLE HYPOTHESES EVALUATION
eval_h1 <- TRUE  # Set to FALSE to skip H1 hypotheses
eval_h2 <- FALSE  # Set to FALSE to skip H2 hypotheses

```

```{r}
#| label: load-data
#| echo: false
#| message: false
#| warning: false

# Load raw data
data.panel.raw <- read_csv("data/panel.csv.gz", show_col_types = FALSE)
data.intake.raw <- read_csv("data/intake.csv.gz", show_col_types = FALSE)

# Process intake data (demographics, scaled variables)
data.intake <- process_intake("data/intake.csv.gz")

# Process panel data (compute derived sleep/wellbeing variables, merge with intake)
data.panel <- process_panel("data/panel.csv.gz", data.intake) |>
  dplyr::select(pid, wave, region, starts_with(c("mctq", "eps", "psqi")),
                total_hours_sleep, wemwbs, epsTotal,
                age_scaled, bmi_scaled, SES_index_scaled, msf_sc_numeric, gender) |>
  mutate(
    pid = as.character(pid)
  )

# Load gaming data
data.nin <- read_csv("data/nintendo.csv.gz", show_col_types = FALSE)
data.xbox <- read_csv("data/xbox.csv.gz", show_col_types = FALSE)
data.steam <- read_csv("data/steam.csv.gz", show_col_types = FALSE)

# Create participant-specific study start dates based on first completed panel survey
participant_start_dates <- data.panel.raw |>
  mutate(date = as_datetime(date)) |>
  group_by(pid) |>
  summarise(studyStartDate = min(date, na.rm = TRUE)) |>
  ungroup() |>
  mutate(pid = as.character(pid))

```

```{r}
#| label: merge data
#| echo: false
#| message: false
#| warning: false

# Standardize column names across gaming platforms
# Nintendo: session_start, session_end, duration
# Xbox: session_start, session_end, duration
# Steam: session_start, session_end (need to compute duration)

# Reference date for identifying future sessions
ref_date <- now()

# Helper function to efficiently calculate concurrent sessions using data.table
calculate_concurrent_sessions <- function(data) {
  # Convert to data.table for efficient overlap calculation
  dt <- as.data.table(data)
  dt[, session_id := .I]

  # Use foverlaps for efficient interval overlap detection
  dt_intervals <- dt[, .(pid, session_id, start = sessionStart, end = sessionEnd)]
  setkey(dt_intervals, pid, start, end)

  # Self-join to find overlapping sessions within each participant
  overlaps <- foverlaps(dt_intervals, dt_intervals, type = "any", nomatch = 0L)

  # Count overlaps for each session
  n_concurrent <- overlaps[, .(n_concurrent = .N), by = .(pid, session_id)]

  # Merge back to original data
  dt <- merge(dt, n_concurrent, by = c("pid", "session_id"), all.x = TRUE)
  dt[is.na(n_concurrent), n_concurrent := 1]
  dt[, session_id := NULL]

  return(as_tibble(dt))
}

# XBOX: Apply data quality heuristics
data.xbox.std <- data.xbox |>
  rename(sessionStart = session_start, sessionEnd = session_end) |>
  mutate(
    date = as_date(sessionStart),
    platform = "Xbox",
    # Calculate duration in minutes for consistency
    duration_minutes = duration,
    # Heuristic (a): Flag sessions in the future
    flag_future = sessionStart > ref_date | sessionEnd > ref_date,
    # Heuristic (b): Flag sessions longer than 10 hours (600 minutes)
    flag_long_session = duration_minutes > 600
  ) |>
  # Heuristic (c): Calculate concurrent sessions using efficient method
  calculate_concurrent_sessions() |>
  mutate(flag_concurrent = n_concurrent >= 3)

# NINTENDO: Apply data quality heuristics
data.nin.std <- data.nin |>
  rename(sessionStart = session_start, sessionEnd = session_end) |>
  mutate(
    date = as_date(sessionStart),
    platform = "Nintendo",
    duration_minutes = duration,
    flag_future = sessionStart > ref_date | sessionEnd > ref_date,
    flag_long_session = duration_minutes > 600
  ) |>
  calculate_concurrent_sessions() |>
  mutate(flag_concurrent = n_concurrent >= 3)

# STEAM: Apply data quality heuristics (using existing concurrent_titles column)
data.steam.std <- data.steam |>
  rename(sessionStart = session_start, sessionEnd = session_end) |>
  mutate(
    date = as_date(sessionStart),
    platform = "Steam",
    duration_minutes = as.numeric(difftime(sessionEnd, sessionStart, units = "mins")),
    flag_future = sessionStart > ref_date | sessionEnd > ref_date,
    flag_long_session = duration_minutes > 600,
    # Steam has concurrent_titles already computed
    n_concurrent = if_else(is.na(concurrent_titles), 1L, as.integer(concurrent_titles)),
    flag_concurrent = n_concurrent >= 3
  )

# Report data quality statistics before filtering
cat("\n=== DATA QUALITY HEURISTICS ===\n\n")

report_quality <- function(data, platform_name) {
  total <- nrow(data)
  n_future <- sum(data$flag_future, na.rm = TRUE)
  n_long <- sum(data$flag_long_session, na.rm = TRUE)
  n_concurrent <- sum(data$flag_concurrent, na.rm = TRUE)
  n_any_flag <- sum(data$flag_future | data$flag_long_session | data$flag_concurrent, na.rm = TRUE)
  pct_removed <- round(100 * n_any_flag / total, 1)

  cat(sprintf("%s:\n", platform_name))
  cat(sprintf("  Total sessions: %d\n", total))
  cat(sprintf("  Sessions in future: %d (%.1f%%)\n", n_future, 100*n_future/total))
  cat(sprintf("  Sessions >10 hours: %d (%.1f%%)\n", n_long, 100*n_long/total))
  cat(sprintf("  Sessions with 3+ concurrent games: %d (%.1f%%)\n", n_concurrent, 100*n_concurrent/total))
  cat(sprintf("  Total flagged for removal: %d (%.1f%%)\n\n", n_any_flag, pct_removed))
}

report_quality(data.xbox.std, "Xbox")
report_quality(data.steam.std, "Steam")
report_quality(data.nin.std, "Nintendo")

# Combine quality flags into a single exclusion flag
data.xbox.std <- data.xbox.std |>
  mutate(exclude_quality = flag_future | flag_long_session | flag_concurrent)

data.steam.std <- data.steam.std |>
  mutate(exclude_quality = flag_future | flag_long_session | flag_concurrent)

data.nin.std <- data.nin.std |>
  mutate(exclude_quality = flag_future | flag_long_session | flag_concurrent)

# merge xbox, steam and nintendo (keeping quality flags for transparency)
data.gaming <- bind_rows(data.xbox.std, data.steam.std, data.nin.std) |>
  mutate(pid = as.character(pid)) |>
  # Filter out sessions flagged for quality issues
  filter(!exclude_quality) |>
  # Join participant-specific study start dates
  left_join(participant_start_dates, by = "pid") |>

  mutate(

    # redefine day to begin and end at 4am, rather than midnight, so we can properly
    # assign late-night sessions to the previous calendar day
    dateRecoded = if_else(hour(sessionStart) < 6, date - 1, date),

    # calculate minutes_played for data.gaming using sessionEnd and sessionStart
    # create a binary variable for data.gaming called latenight if the sessionStart is between 23:00 and 06:00
    # create an isWeekend variable for data.gaming if the sessionStart is on a Saturday, Sunday or Friday
    minutes_played = as.numeric(difftime(sessionEnd, sessionStart, units = "mins")),
    latenight = ifelse(hour(sessionStart) >= 23 | hour(sessionStart) < 6, 1, 0),
    isWeekend = ifelse(weekdays(sessionStart) %in% c("Friday", "Saturday"), 1, 0),

    # calculate late night using lubridate::interval objects
    interval_gaming = interval(sessionStart, sessionEnd),
    interval_latenight = interval(dateRecoded + hours(23), dateRecoded + hours(30)), # gets the 11pm to 6am following day interval from date
    latenightMinutes = as.numeric(intersect(interval_gaming, interval_latenight))/60 # calculate overlap in minutes
  ) |>

  # assign each session to a wave based on participant-specific study start date
  # Each participant's study begins when they complete their first panel survey
  mutate(
    days_since_start = as.numeric(difftime(sessionStart, studyStartDate, units = "days")),
    month = case_when(
      days_since_start >= 0 & days_since_start <= 28 ~ 2,
      days_since_start >= 29 & days_since_start <= 56 ~ 4,
      days_since_start >= 57 & days_since_start <= 84 ~ 6,
      TRUE ~ NA_real_
    ),
    # Define biweekly waves (14-day intervals) that end at day 84
    wave = case_when(
      days_since_start >= 0 & days_since_start <= 14 ~ 1,
      days_since_start >= 15 & days_since_start <= 28 ~ 2,
      days_since_start >= 29 & days_since_start <= 42 ~ 3,
      days_since_start >= 43 & days_since_start <= 56 ~ 4,
      days_since_start >= 57 & days_since_start <= 70 ~ 5,
      days_since_start >= 71 & days_since_start <= 84 ~ 6,
      TRUE ~ NA_real_  # Assign NA for days beyond 84
    )
  ) |>
  # Remove the studyStartDate column as it's no longer needed
  select(-studyStartDate) 

# group gaming by PID, wave and latenight and calculate daily average minutes_played
gamingMonthly <- data.gaming |>
  # Filter to only include gaming within the study period (months 2, 4, 6)
  filter(!is.na(month), month %in% c(2, 4, 6)) |>
  group_by(pid, month, isWeekend) %>%
  summarise(
    ln_monthly_avg_minutes_played = sum(latenightMinutes)/28,
    ln_monthly_total_minutes_played = sum(latenightMinutes),
  ) |>
  left_join(data.panel |> dplyr::select(-msf_sc_numeric) |> filter(wave %in% c(2, 4, 6)),
            by = c("pid","month" = "wave")) |>
  left_join(data.panel |> dplyr::select(pid, msf_sc_numeric) |> filter(!is.na(msf_sc_numeric)),
            by = c("pid")) |> # hacky way to make sure chronotype (measured in wave 1 only) doesn't get lost
  mutate(
    ln_monthly_avg_minutes_played = replace_na(ln_monthly_avg_minutes_played, 0),
    ln_monthly_total_minutes_played = replace_na(ln_monthly_total_minutes_played, 0)
  ) |>
  ungroup() |>
  arrange(as.integer(pid), month)

# group gaming by PID, wave and latenight and calculate daily average minutes_played
gamingBiweekly <- data.gaming |>
  # Filter to only include gaming within the study period (waves 1-6, days 0-84)
  filter(!is.na(wave), wave %in% 1:6) |>
  group_by(pid, wave, isWeekend) |>
  summarise(
    ln_biweekly_avg_minutes_played = sum(latenightMinutes)/14,
  ) |>
  left_join(data.panel |> dplyr::select(-msf_sc_numeric), by = c("pid", "wave")) |>
  left_join(data.panel |> dplyr::select(pid, msf_sc_numeric) |> filter(!is.na(msf_sc_numeric)),
            by = c("pid")) |> # hacky way to make sure chronotype (measured in wave 1 only) doesn't get lost
  mutate(ln_biweekly_avg_minutes_played = replace_na(ln_biweekly_avg_minutes_played, 0)) |>
  ungroup() |>
  arrange(as.integer(pid), wave) |>
  dplyr::select(pid, wave, msf_sc_numeric, everything())

```

## Sample Demographics

The analytical sample includes all participants who contributed at least one datapoint on at least one of the four outcome variables (sleep quality, sleep duration, daytime sleepiness, or wellbeing). The table below presents the demographic composition of this sample along key covariates.

```{r}
#| label: tbl-demographics
#| code-summary: "Demographics table"
#| tbl-cap: "Sample Demographics and Key Covariates"

# Load tinytable if not already loaded
if (!require("tinytable")) install.packages("tinytable")
library(tinytable)

# Identify analytical sample: participants with at least one non-missing outcome
analytical_sample <- gamingMonthly |>
  filter(!is.na(psqi_global) | !is.na(total_hours_sleep) |
         !is.na(epsTotal) | !is.na(wemwbs)) |>
  distinct(pid) |>
  pull(pid)

# Get demographic data for analytical sample
# Use the processed intake data which has properly calculated BMI
demographics_data <- data.intake |>
  filter(pid %in% analytical_sample)

# Create summary table with columns: Characteristic, N, Percent, Mean (SD)
# Using section headers within the data instead of group_tt()
summary_rows <- tibble(
  Characteristic = character(),
  N = character(),
  Percent = character(),
  `Mean (SD)` = character()
)

# Sample size
total_n <- nrow(demographics_data)
summary_rows <- bind_rows(summary_rows,
  tibble(Characteristic = "**Sample Size**", N = "", Percent = "", `Mean (SD)` = ""))
summary_rows <- bind_rows(summary_rows,
  tibble(Characteristic = "Total", N = as.character(total_n),
         Percent = "", `Mean (SD)` = ""))

# Country
summary_rows <- bind_rows(summary_rows,
  tibble(Characteristic = "**Country**", N = "", Percent = "", `Mean (SD)` = ""))

country_dist <- demographics_data |>
  count(country) |>
  arrange(desc(n))

for (i in 1:nrow(country_dist)) {
  summary_rows <- bind_rows(summary_rows,
    tibble(
      Characteristic = paste0("    ", country_dist$country[i]),  # 4 spaces for indent
      N = as.character(country_dist$n[i]),
      Percent = sprintf("%.1f", 100 * country_dist$n[i] / total_n),
      `Mean (SD)` = ""
    ))
}

# Age
summary_rows <- bind_rows(summary_rows,
  tibble(Characteristic = "**Age, years**", N = "", Percent = "", `Mean (SD)` = ""))
summary_rows <- bind_rows(summary_rows,
  tibble(
    Characteristic = "",
    N = "",
    Percent = "",
    `Mean (SD)` = sprintf("%.1f (%.1f)",
                          mean(demographics_data$age, na.rm = TRUE),
                          sd(demographics_data$age, na.rm = TRUE))
  ))

# Age bins
age_bins <- demographics_data |>
  mutate(
    age_bin = case_when(
      age >= 18 & age <= 24 ~ "18–24",
      age >= 25 & age <= 30 ~ "25–30",
      age >= 31 & age <= 35 ~ "31–35",
      age >= 36 & age <= 40 ~ "36–40",
      TRUE ~ NA_character_
    )
  ) |>
  count(age_bin) |>
  filter(!is.na(age_bin)) |>
  arrange(age_bin)

for (i in 1:nrow(age_bins)) {
  summary_rows <- bind_rows(summary_rows,
    tibble(
      Characteristic = paste0("    ", age_bins$age_bin[i]),  # 4 spaces for indent
      N = as.character(age_bins$n[i]),
      Percent = sprintf("%.1f", 100 * age_bins$n[i] / total_n),
      `Mean (SD)` = ""
    ))
}

# Gender
summary_rows <- bind_rows(summary_rows,
  tibble(Characteristic = "**Gender**", N = "", Percent = "", `Mean (SD)` = ""))

gender_categories <- demographics_data |>
  mutate(
    gender_cat = case_when(
      gender == "Man" ~ "Man",
      gender == "Woman" ~ "Woman",
      gender %in% c("Non-binary", "Genderqueer", "Genderfluid", "Agender",
                    "Demiboy", "Demiman", "He/They") ~ "Non-binary/Other",
      str_detect(tolower(gender), "trans") ~ "Transgender",
      is.na(gender) ~ "Not reported",
      TRUE ~ "Other"
    )
  ) |>
  count(gender_cat) |>
  arrange(desc(n))

for (i in 1:nrow(gender_categories)) {
  summary_rows <- bind_rows(summary_rows,
    tibble(
      Characteristic = paste0("    ", gender_categories$gender_cat[i]),  # 4 spaces for indent
      N = as.character(gender_categories$n[i]),
      Percent = sprintf("%.1f", 100 * gender_categories$n[i] / total_n),
      `Mean (SD)` = ""
    ))
}

# BMI
summary_rows <- bind_rows(summary_rows,
  tibble(Characteristic = "**BMI, kg/m²**", N = "", Percent = "", `Mean (SD)` = ""))
summary_rows <- bind_rows(summary_rows,
  tibble(
    Characteristic = "",
    N = "",
    Percent = "",
    `Mean (SD)` = sprintf("%.1f (%.1f)",
                          mean(demographics_data$bmi, na.rm = TRUE),
                          sd(demographics_data$bmi, na.rm = TRUE))
  ))

# SES Index
summary_rows <- bind_rows(summary_rows,
  tibble(Characteristic = "**SES Index**", N = "", Percent = "", `Mean (SD)` = ""))
summary_rows <- bind_rows(summary_rows,
  tibble(
    Characteristic = "",
    N = "",
    Percent = "",
    `Mean (SD)` = sprintf("%.2f (%.2f)",
                          mean(demographics_data$SES_index, na.rm = TRUE),
                          sd(demographics_data$SES_index, na.rm = TRUE))
  ))

# Identify which rows are section headers (contain **) and sub-items (start with spaces)
header_rows <- which(str_detect(summary_rows$Characteristic, "^\\*\\*"))
sub_item_rows <- which(str_detect(summary_rows$Characteristic, "^    "))

# Display with tinytable
summary_rows |>
  tt(
    caption = "Sample Demographics and Key Covariates",
    notes = "SES Index is a composite of education and employment status (range 1–3)."
  ) |>
  # Align columns
  style_tt(j = 1, align = "l") |>
  style_tt(j = 2:4, align = "r") |>
  # Style section headers: bold
  style_tt(i = header_rows, bold = TRUE) |>
  # Add left padding to sub-items for indentation
  style_tt(i = sub_item_rows, j = 1, indent = 1) |>
  # Format the markdown (remove ** from display but keep bold styling)
  format_tt(i = header_rows, j = 1, fn = function(x) str_remove_all(x, "\\*\\*")) |>
  # Remove leading spaces from sub-items (since we're using CSS indent instead)
  format_tt(i = sub_item_rows, j = 1, fn = function(x) str_trim(x))
```

## Late-Night Gaming Descriptives

```{r}
#| label: gameplay-descriptives
#| code-summary: "Histogram of monthly total late-night gaming"
#| fig-width: 10
#| fig-height: 5

# Prepare gameplay data - aggregate to participant level for histogram
# Using daily average thresholds: None = 0, Low < 10.7 min/day, Moderate < 32.1 min/day, High >= 32.1 min/day
participant_gameplay <- gamingMonthly |>
  filter(month %in% c(2, 4, 6)) |>  # Only include the three study months
  dplyr::select(
    pid,
    month,
    ln_monthly_avg_minutes_played
  ) |>
  filter(!is.na(ln_monthly_avg_minutes_played)) |>
  # Aggregate to participant-month level (because data has weekend/weekday split)
  group_by(pid, month) |>
  summarise(
    month_avg = mean(ln_monthly_avg_minutes_played, na.rm = TRUE),
    .groups = "drop"
  ) |>
  # Then aggregate to participant level (average across all study months)
  group_by(pid) |>
  summarise(
    avg_minutes_per_day = mean(month_avg, na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(
    # Create categories based on daily average
    category = case_when(
      avg_minutes_per_day == 0 ~ "0 min",
      avg_minutes_per_day <= 10 ~ "0-10 min/day",
      avg_minutes_per_day <= 20 ~ "10-20 min/day",
      avg_minutes_per_day <= 30 ~ "20-30 min/day",
      TRUE ~ "30+ min/day"
    ),
    category = factor(category, levels = c("0 min", "0-10 min/day",
                                           "10-20 min/day", "20-30 min/day",
                                           "30+ min/day"))
  )

# Print detailed summary statistics based on participant averages
participant_gameplay |>
  summarise(
    N = n(),
    Mean = mean(avg_minutes_per_day, na.rm = TRUE),
    SD = sd(avg_minutes_per_day, na.rm = TRUE),
    Median = median(avg_minutes_per_day, na.rm = TRUE),
    Min = min(avg_minutes_per_day, na.rm = TRUE),
    Max = max(avg_minutes_per_day, na.rm = TRUE),
    .groups = "drop"
  ) |>
  knitr::kable(digits = 2, caption = "Descriptive Statistics for Average Daily Late-Night Gaming Across Study Period (Per Participant)")
```

```{r}
#| label: participant-category-table
#| code-summary: "Participant distribution by late-night gaming category"

# Load tinytable if not already loaded
if (!require("tinytable")) install.packages("tinytable")
library(tinytable)

# Calculate additional metrics for the summary table
# Need to go back to month-level data to count months with gaming
participant_totals <- gamingMonthly |>
  filter(month %in% c(2, 4, 6)) |>
  dplyr::select(pid, month, ln_monthly_avg_minutes_played) |>
  filter(!is.na(ln_monthly_avg_minutes_played)) |>
  group_by(pid, month) |>
  summarise(
    month_avg = mean(ln_monthly_avg_minutes_played, na.rm = TRUE),
    .groups = "drop"
  ) |>
  group_by(pid) |>
  summarise(
    avg_minutes_per_day = mean(month_avg, na.rm = TRUE),
    n_months_with_gaming = sum(month_avg > 0),  # Count months with any late-night gaming
    .groups = "drop"
  ) |>
  mutate(
    category = case_when(
      avg_minutes_per_day == 0 ~ "0 min",
      avg_minutes_per_day <= 10 ~ "0-10 min/day",
      avg_minutes_per_day <= 20 ~ "10-20 min/day",
      avg_minutes_per_day <= 30 ~ "20-30 min/day",
      TRUE ~ "30+ min/day"
    ),
    category = factor(category, levels = c("0 min", "0-10 min/day",
                                           "10-20 min/day", "20-30 min/day",
                                           "30+ min/day"))
  )

# Create summary table
summary_table <- participant_totals |>
  group_by(category) |>
  summarise(
    n_participants = n(),
    pct_participants = round(100 * n() / nrow(participant_totals), 1),
    mean_months_with_gaming = round(mean(n_months_with_gaming), 1),
    mean_avg_minutes = round(mean(avg_minutes_per_day), 1),
    median_avg_minutes = round(median(avg_minutes_per_day), 1),
    .groups = "drop"
  )

# Display with tinytable - rename columns to avoid LaTeX issues with underscores
summary_table |>
  rename(
    Category = category,
    `N Participants` = n_participants,
    `% Participants` = pct_participants,
    `Mean Months with Gaming` = mean_months_with_gaming,
    `Mean Avg Min/Day` = mean_avg_minutes,
    `Median Avg Min/Day` = median_avg_minutes
  ) |>
  tt(
    caption = "Participant Distribution by Average Daily Late-Night Gaming Across Study Period"
  ) |>
  style_tt(
    j = 1,
    align = "l"
  ) |>
  style_tt(
    j = 2:6,
    align = "r"
  ) |>
  format_tt(
    j = 2:6,
    digits = 1
  )
```

## Sleep and Wellbeing Descriptives

Note: The dataset contains 7 WEMWBS items (SWEMWBS short form, range 7-35) rather than the full 14-item WEMWBS (range 14-70).

```{r}
#| label: raincloud-descriptives
#| code-summary: "Raincloud plots for sleep and wellbeing variables"
#| fig-width: 10
#| fig-height: 8

# Load ggdist for raincloud plots
if (!require("ggdist")) install.packages("ggdist")
library(ggdist)

# Prepare data for raincloud plots - select key variables (excluding gameplay)
descriptive_data <- gamingMonthly |>
  dplyr::select(
    pid,
    month,
    global_psqi = psqi_global,
    sleep_duration = total_hours_sleep,
    daytime_sleepiness = epsTotal,
    wellbeing = wemwbs
  ) |>
  pivot_longer(
    cols = c(global_psqi, sleep_duration, daytime_sleepiness, wellbeing),
    names_to = "variable",
    values_to = "value"
  ) |>
  filter(!is.na(value)) |>
  mutate(
    variable = factor(variable,
                     levels = c("global_psqi", "sleep_duration", "daytime_sleepiness", "wellbeing"),
                     labels = c("Global PSQI Score (0-21)",
                               "Sleep Duration (hours)",
                               "Daytime Sleepiness (EPS: 0-24)",
                               "Wellbeing (WEMWBS: 7-35)"))
  )

# All variables are continuous, so use raincloud for all
data_continuous <- descriptive_data

# Create raincloud plot for continuous variables with facets
ggplot(data_continuous, aes(x = 1, y = value, fill = variable)) +
  # Boxplot - left layer
  geom_boxplot(
    width = 0.15,
    outlier.shape = NA,
    alpha = 0.5
  ) +
  # Half violin (density distribution) - right layer
  stat_slab(
    adjust = 2,
    side = "right",
    scale = 0.6,
    normalize = "groups",
    alpha = 0.7,
    position = position_nudge(x = 0.2)
  ) +
  # Facet by variable with free y-scales
  facet_wrap(~ variable, scales = "free_y", nrow = 1) +
  # Styling
  scale_fill_brewer(palette = "Set2", guide = "none") +
  labs(
    title = "Distribution of Sleep and Wellbeing Variables",
    y = "Value",
    x = ""
  ) +
  theme_minimal(base_size = 12) +
  theme(
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.text = element_text(face = "bold", size = 10),
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5)
  )

# Print summary statistics
descriptive_data |>
  group_by(variable) |>
  summarise(
    `Unique Participants` = n_distinct(pid),
    N = n(),
    Mean = mean(value, na.rm = TRUE),
    SD = sd(value, na.rm = TRUE),
    Median = median(value, na.rm = TRUE),
    Min = min(value, na.rm = TRUE),
    Max = max(value, na.rm = TRUE),
    .groups = "drop"
  ) |>
  knitr::kable(digits = 2, caption = "Descriptive Statistics for Sleep and Wellbeing Variables")
```


## H1a: Late-night gaming is associated with poorer sleep quality.

Multilevel ordinal regression whereby monthly average minutes played predicts sleep quality (PSQI), controlling for age, BMI, SES index, region, and whether playtime falls on a weekend, with a random intercept for participants.

Model syntax: `psqi_global ~ ln_monthly_avg_minutes_played + age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend + (1 | pid)`

```{r}
#| label: h1a
#| code-summary: "Fit H1a model"
#| eval: !expr eval_h1

# Fit the model using global PSQI score (0-21, higher = worse sleep quality)
model.h1a <- lmer(psqi_global ~ ln_monthly_avg_minutes_played + (1 | pid) +
                    age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend,
                  data = gamingMonthly)

modelsummary(
  list(`Model H1a` = model.h1a),
  fmt = 2,
  estimate  = "{estimate} [{conf.low}, {conf.high}]{stars}",
  statistic = NULL
)
```


## H1b: Late-night gaming is associated with shorter sleep duration.

Multilevel linear regression whereby monthly average minutes played predicts total hours of sleep (PSQI), controlling for age, BMI, SES index, region, gender, and whether playtime falls on a weekend, with a random intercept for participants.

**Deviation from pre-registered analysis plan**: The pre-registered random effects structure `(1 + ln_monthly_avg_minutes_played | pid) + (1 | gender)` resulted in a singular fit warning. The random slope variance was estimated at near-zero (SD = 0.004), and the gender random effect variance was also estimated at zero, indicating insufficient variation in both components. To address these computational issues, we simplified the random effects structure to a single random intercept for participants: `(1 | pid)`. Gender is retained as a fixed effect covariate. This change does not affect the fixed effects (the hypothesis tests) but provides more stable variance estimates.

Model syntax: `total_hours_sleep ~ ln_monthly_avg_minutes_played + age_scaled + bmi_scaled + SES_index_scaled + gender + region + isWeekend + (1 | pid)`

```{r}
#| label: h1b
#| code-summary: "Fit H1b model"

# Fit the model with simplified random effects structure
# Original: (1 + ln_monthly_avg_minutes_played | pid) + (1 | gender) caused singular fit
# Both random slope and gender random intercept had zero/near-zero variance
model.h1b <- lmer(total_hours_sleep ~ ln_monthly_avg_minutes_played +
                    (1 | pid) +
                    age_scaled + bmi_scaled + SES_index_scaled + gender + region + isWeekend,
                  data = gamingMonthly
                  )

# Summarize the model using modelsummary
modelsummary(
  list(`Model H1b` = model.h1b),
  fmt = 2,
  estimate  = "{estimate} [{conf.low}, {conf.high}]{stars}",
  statistic = NULL
)
```


## H1c: Late-night gaming is associated with lower well-being.

Multilevel linear regression whereby biweekly average minutes played predicts wellbeing (WEMWBS), controlling for age, BMI, SES index, region, gender, and whether playtime falls on a weekend, with a random intercept and slope for participants and a random intercept for gender.

**Deviation from pre-registered analysis plan**: The pre-registered model specification with the default optimizer resulted in a convergence warning (max|grad| = 0.00817, tolerance = 0.002), indicating that the optimization algorithm did not fully converge. To address this computational issue, we use the BOBYQA optimizer instead of the default Nelder-Mead optimizer. This change affects only the optimization algorithm used to fit the model, not the model structure itself. The random effects structure and all fixed effects remain exactly as pre-registered.

Model syntax: `wemwbs ~ ln_biweekly_avg_minutes_played + age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend + (1 + ln_biweekly_avg_minutes_played | pid) + (1 | gender)`

```{r}
#| label: h1c
#| code-summary: "Fit H1c model"
#| eval: !expr eval_h1

# Fit the model with BOBYQA optimizer to resolve convergence issues
# Original optimizer (default) caused convergence warning
model.h1c <- lmer(wemwbs ~ ln_biweekly_avg_minutes_played + (1 + ln_biweekly_avg_minutes_played | pid) +
                    age_scaled + bmi_scaled + SES_index_scaled + (1 | gender) + region + isWeekend,
                  data = gamingBiweekly,
                  control = lmerControl(optimizer = "bobyqa"))

modelsummary(
  list(`Model H1c` = model.h1c),
  fmt = 2,
  estimate  = "{estimate} [{conf.low}, {conf.high}]{stars}",
  statistic = NULL
)

```

## H1d: Late-night gaming is associated with higher daytime sleepiness.

Multilevel linear regression whereby monthly average minutes played predicts daytime sleepiness (Epworth Sleepiness Scale), controlling for age, BMI, SES index, region, gender, and whether playtime falls on a weekend, with a random intercept for participants and a random intercept for gender.

**Deviation from pre-registered analysis plan**: The pre-registered random effects structure `(1 + ln_monthly_avg_minutes_played | pid)` resulted in a singular fit warning, with the correlation between random intercept and slope estimated at -1.00, indicating perfect collinearity. To address this computational issue, we simplified the random effects structure to random intercepts only: `(1 | pid) + (1 | gender)`. This change does not affect the fixed effects (the hypothesis tests) but provides more stable variance estimates.

Model syntax: `epsTotal ~ ln_monthly_avg_minutes_played + age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend + (1 | pid) + (1 | gender)`

```{r}
#| label: h1d
#| code-summary: "Fit H1d model"
#| eval: !expr eval_h1

# Fit the model with simplified random effects structure
# Original: (1 + ln_monthly_avg_minutes_played | pid) caused singular fit
model.h1d <- lmer(epsTotal ~ ln_monthly_avg_minutes_played +
                    (1 | pid) + (1 | gender) +
                    age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend,
                  data = gamingMonthly)

# Summarize the model using modelsummary
modelsummary(
  list(`Model H1d` = model.h1d),
  fmt = 2,
  estimate  = "{estimate} [{conf.low}, {conf.high}]{stars}",
  statistic = NULL
)
```

```{r}
#| label: tbl-h1-combined
#| code-summary: "Combined summary table for all H1 models"
#| eval: !expr eval_h1
#| tbl-cap: "Summary of H1 Hypotheses: Effects of Late-Night Gaming on Sleep and Wellbeing"
#| output: asis

# Combine all H1 models into a single table
# Custom function to reorder coefficients while preserving ALL random effects

# Create output directory if it doesn't exist
if (!dir.exists("output")) {
  dir.create("output")
}

# Helper function: reorder fixed effects while preserving random effects
modelsummary_reordered <- function(models, coef_order, output_file = NULL, ...) {
  # Get full output as dataframe
  df <- modelsummary(models, output = 'data.frame', ...)

  # Identify fixed effects vs GOF (goodness-of-fit) rows
  # GOF rows include: SD, Cor, Num.Obs., ICC, R2, AIC, BIC, etc.
  is_gof <- grepl("^(SD|Cor|Num\\.|ICC|R2|AIC|BIC|Log)", df$term)
  fixed_df <- df[!is_gof, ]
  gof_df <- df[is_gof, ]

  # Reorder fixed effects according to coef_order
  fixed_df$order <- match(fixed_df$term, coef_order)
  fixed_df <- fixed_df[order(fixed_df$order, na.last = TRUE), ]
  fixed_df$order <- NULL

  # Recombine: fixed effects first, then GOF (which includes random effects)
  result_df <- rbind(fixed_df, gof_df)

  # If output file specified, convert to markdown and save
  if (!is.null(output_file)) {
    # Convert back to modelsummary format for consistent styling
    ms_output <- modelsummary(models, output = output_file, ...)
  }

  # Return the reordered dataframe and create display output
  result_table <- modelsummary(models, ...)

  return(result_df)
}

# Define desired coefficient order
coef_order <- c(
  "ln_monthly_avg_minutes_played",
  "ln_biweekly_avg_minutes_played",
  "age_scaled",
  "bmi_scaled",
  "SES_index_scaled",
  "regionUS",
  "isWeekend",
  "(Intercept)"
)

# First create the standard table to get proper formatting
h1_table_df <- modelsummary(
  list(
    `H1a: Sleep Quality` = model.h1a,
    `H1b: Sleep Duration` = model.h1b,
    `H1c: Wellbeing` = model.h1c,
    `H1d: Daytime Sleepiness` = model.h1d
  ),
  output = 'data.frame',
  fmt = 2,
  estimate  = "{estimate} [{conf.low}, {conf.high}]{stars}",
  statistic = NULL,
  gof_omit = "AIC|BIC|Log|RMSE|R2"
)

# Separate fixed effects, random effects (SD/Cor), and GOF (Num.Obs., ICC)
is_random <- grepl("^(SD|Cor)", h1_table_df$term)
is_gof <- grepl("^(Num\\.|ICC|R2)", h1_table_df$term)
is_fixed <- !is_random & !is_gof

fixed_df <- h1_table_df[is_fixed, ]
random_df <- h1_table_df[is_random, ]
gof_df <- h1_table_df[is_gof, ]

# Reorder fixed effects
fixed_df$order <- match(fixed_df$term, coef_order)
fixed_df <- fixed_df[order(fixed_df$order, na.last = TRUE), ]
fixed_df$order <- NULL

# Load kableExtra for better table formatting
library(kableExtra)

# Detect output format first
is_html <- knitr::is_html_output()
is_latex <- knitr::is_latex_output()

if (is_html) {
  # Use kableExtra for HTML output - use coef_map to control exact order including random effects
  modelsummary(
    list(
      `H1a: Sleep Quality` = model.h1a,
      `H1b: Sleep Duration` = model.h1b,
      `H1c: Wellbeing` = model.h1c,
      `H1d: Daytime Sleepiness` = model.h1d
    ),
    fmt = 2,
    estimate  = "{estimate} [{conf.low}, {conf.high}]{stars}",
    statistic = NULL,
    gof_omit = "AIC|BIC|Log|RMSE|R2",
    coef_map = c(
      "(Intercept)" = "Intercept",
      "ln_monthly_avg_minutes_played" = "Late-night gaming (monthly avg, log)",
      "ln_biweekly_avg_minutes_played" = "Late-night gaming (biweekly avg, log)",
      "age_scaled" = "Age (scaled)",
      "bmi_scaled" = "BMI (scaled)",
      "SES_index_scaled" = "SES index (scaled)",
      "regionUS" = "Region: US",
      "isWeekend" = "Weekend",
      "SD (Intercept pid)" = "SD (Intercept | Participant)",
      "SD (ln_monthly_avg_minutes_played pid)" = "SD (Late-night gaming (monthly avg, log) | Participant)",
      "Cor (Intercept~ln_monthly_avg_minutes_played pid)" = "Cor (Intercept ~ Late-night gaming (monthly avg, log) | Participant)",
      "SD (ln_biweekly_avg_minutes_played pid)" = "SD (Late-night gaming (biweekly avg, log) | Participant)",
      "Cor (Intercept~ln_biweekly_avg_minutes_played pid)" = "Cor (Intercept ~ Late-night gaming (biweekly avg, log) | Participant)",
      "SD (Observations)" = "SD (Residual)",
      "SD (Intercept gender)" = "SD (Intercept | Gender)"
    ),
    notes = c("* p < 0.05, ** p < 0.01, *** p < 0.001",
              "Confidence intervals shown in brackets."),
    title = "Summary of H1 Hypotheses: Effects of Late-Night Gaming on Sleep and Wellbeing"
  )
} else {
  # Use simpler format for PDF and DOCX - use coef_map to control exact order including random effects
  modelsummary(
    list(
      `H1a: Sleep Quality` = model.h1a,
      `H1b: Sleep Duration` = model.h1b,
      `H1c: Wellbeing` = model.h1c,
      `H1d: Daytime Sleepiness` = model.h1d
    ),
    fmt = 2,
    estimate  = "{estimate} [{conf.low}, {conf.high}]{stars}",
    statistic = NULL,
    gof_omit = "AIC|BIC|Log|RMSE|R2",
    coef_map = c(
      "(Intercept)" = "Intercept",
      "ln_monthly_avg_minutes_played" = "Late-night gaming (monthly avg, log)",
      "ln_biweekly_avg_minutes_played" = "Late-night gaming (biweekly avg, log)",
      "age_scaled" = "Age (scaled)",
      "bmi_scaled" = "BMI (scaled)",
      "SES_index_scaled" = "SES index (scaled)",
      "regionUS" = "Region: US",
      "isWeekend" = "Weekend",
      "SD (Intercept pid)" = "SD (Intercept | Participant)",
      "SD (ln_monthly_avg_minutes_played pid)" = "SD (Late-night gaming (monthly avg, log) | Participant)",
      "Cor (Intercept~ln_monthly_avg_minutes_played pid)" = "Cor (Intercept ~ Late-night gaming (monthly avg, log) | Participant)",
      "SD (ln_biweekly_avg_minutes_played pid)" = "SD (Late-night gaming (biweekly avg, log) | Participant)",
      "Cor (Intercept~ln_biweekly_avg_minutes_played pid)" = "Cor (Intercept ~ Late-night gaming (biweekly avg, log) | Participant)",
      "SD (Observations)" = "SD (Residual)",
      "SD (Intercept gender)" = "SD (Intercept | Gender)"
    ),
    notes = c("* p < 0.05, ** p < 0.01, *** p < 0.001",
              "Confidence intervals shown in brackets."),
    title = "Summary of H1 Hypotheses: Effects of Late-Night Gaming on Sleep and Wellbeing"
  )
}
```


## H2

### H2a: The negative association between late-night gaming and sleep quality is more pronounced among evening chronotypes.

Multilevel linear regression whereby the interaction between monthly average minutes played and chronotype (MSFsc: mid-sleep on free days corrected for sleep debt on weekdays; MCTQ) predicts sleep quality (global PSQI score), controlling for age, BMI, SES index, region, and whether playtime falls on a weekend, with a random intercept and slope for participants.

Model syntax: `psqi_global ~ ln_monthly_avg_minutes_played * msf_sc_numeric + age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend + (1 + ln_monthly_avg_minutes_played | pid)`

```{r}
#| label: h2a
#| code-summary: "Fit H2a model"
#| eval: !expr eval_h2

# Fit the model using global PSQI score with interaction
model.h2a <- lmer(psqi_global ~ ln_monthly_avg_minutes_played * msf_sc_numeric +
                    (1 + ln_monthly_avg_minutes_played | pid) +
                    age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend,
                  data = gamingMonthly)

modelsummary(
  list(`Model H2a` = model.h2a),
  fmt = 2,
  estimate  = "{estimate} [{conf.low}, {conf.high}]{stars}",
  statistic = NULL
)
```

## H2b: The negative association between late-night gaming and sleep duration is more pronounced among evening chronotypes.

Multilevel linear regression whereby the interaction between monthly average minutes played and chronotype (MSFsc; MCTQ) predicts total hours of sleep, controlling for age, BMI, SES index, region, gender, and whether playtime falls on a weekend, with a random intercept and slope for participants and a random intercept for gender.

Model syntax: `total_hours_sleep ~ ln_monthly_avg_minutes_played * msf_sc_numeric + age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend + (1 + ln_monthly_avg_minutes_played | pid) + (1 | gender)`

```{r}
#| label: h2b
#| code-summary: "Fit H2b model"
#| eval: !expr eval_h2

# Fit the model
model.h2b <- lmer(total_hours_sleep ~ ln_monthly_avg_minutes_played * msf_sc_numeric + (1  | pid) +
                    age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend + (1 | gender),
                  data = gamingMonthly)

# Summarize the model using modelsummary
modelsummary(
  list(`Model H2b` = model.h2b),
  fmt = 2,
  estimate  = "{estimate} [{conf.low}, {conf.high}]{stars}", 
  statistic = NULL
)

```

### H2c: The negative association between late-night gaming and well-being is more pronounced among evening chronotypes.

Multilevel linear regression whereby the interaction between biweekly average minutes played and chronotype (MSFsc; MCTQ) predicts wellbeing (WEMWBS), controlling for age, BMI, SES index, region, gender, and whether playtime falls on a weekend, with a random intercept for participants and a random intercept for gender.

Model syntax: `wemwbs ~ ln_biweekly_avg_minutes_played * msf_sc_numeric + age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend + (1 | pid) + (1 | gender)`

```{r}
#| label: h2c
#| code-summary: "Fit H2c model"
#| eval: !expr eval_h2

# Fit the model
model.h2c <- lmer(wemwbs ~ ln_biweekly_avg_minutes_played * msf_sc_numeric + (1 | pid) +
                    age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend + (1 | gender),
                  data = gamingBiweekly)
modelsummary(
  list(`Model h2c` = model.h2c),
  fmt = 2,
  estimate  = "{estimate} [{conf.low}, {conf.high}]{stars}", 
  statistic = NULL
)

```

### H2d: The negative association between late-night gaming and daytime sleepiness is more pronounced among evening chronotypes.

Multilevel linear regression whereby the interaction between monthly average minutes played and chronotype (MSFsc; MCTQ) predicts daytime sleepiness (Epworth Sleepiness Scale), controlling for age, BMI, SES index, region, gender, and whether playtime falls on a weekend, with a random intercept and slope for participants and a random intercept for gender.

Model syntax: `epsTotal ~ ln_monthly_avg_minutes_played * msf_sc_numeric + age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend + (1 + ln_monthly_avg_minutes_played | pid) + (1 | gender)`

```{r}
#| label: h2d
#| code-summary: "Fit H2d model"
#| eval: !expr eval_h2

model.h2d <- lmer(epsTotal ~ ln_monthly_avg_minutes_played * msf_sc_numeric + (1  | pid) +
                    age_scaled + bmi_scaled + SES_index_scaled + region + isWeekend + (1 | gender),
                  data = gamingMonthly)
                  
modelsummary(
  list(`Model H2d` = model.h2d),
  fmt = 2,
  estimate  = "{estimate} [{conf.low}, {conf.high}]{stars}", 
  statistic = NULL
)
```


::::

# Discussion

# References

:::{#refs}
:::

```{=typst}
#show: appendix.with()
```
# Appendix content here
